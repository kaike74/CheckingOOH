// =============================================================================
// üì∑ GERENCIAMENTO DA C√ÇMERA - CHECKING OOH
// =============================================================================

let cameraStream = null;
let cameraVideo = null;
let cameraCanvas = null;
let currentExibidora = null;
let currentPontoId = null;
let currentTipo = null;

/**
 * üì∑ ABRIR C√ÇMERA
 * Inicia a c√¢mera e abre o modal
 */
async function openCamera() {
    try {
        Logger.info('Abrindo c√¢mera...');
        
        // Verificar se o navegador suporta getUserMedia
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            throw new Error('C√¢mera n√£o √© suportada neste navegador');
        }
        
        // Abrir modal da c√¢mera
        document.getElementById('camera-modal').style.display = 'flex';
        
        // Obter elementos
        cameraVideo = document.getElementById('camera-video');
        cameraCanvas = document.getElementById('camera-canvas');
        
        // Solicitar acesso √† c√¢mera
        cameraStream = await navigator.mediaDevices.getUserMedia({
            video: CONFIG.CAMERA.VIDEO_CONSTRAINTS,
            audio: false
        });
        
        // Conectar stream ao v√≠deo
        cameraVideo.srcObject = cameraStream;
        
        Logger.success('C√¢mera inicializada');
        
    } catch (error) {
        Logger.error('Erro ao abrir c√¢mera', error);
        closeCameraModal();
        
        // Mostrar erro espec√≠fico para o usu√°rio
        let errorMessage = 'N√£o foi poss√≠vel acessar a c√¢mera.';
        
        if (error.name === 'NotAllowedError') {
            errorMessage = 'Permiss√£o de c√¢mera negada. Permita o acesso √† c√¢mera e tente novamente.';
        } else if (error.name === 'NotFoundError') {
            errorMessage = 'Nenhuma c√¢mera encontrada no dispositivo.';
        } else if (error.name === 'NotSupportedError') {
            errorMessage = 'C√¢mera n√£o √© suportada neste navegador.';
        }
        
        alert(errorMessage);
    }
}

/**
 * üì∏ CAPTURAR FOTO
 * Tira uma foto da c√¢mera e processa para upload
 */
async function capturePhoto() {
    try {
        if (!cameraVideo || !cameraCanvas || !cameraStream) {
            throw new Error('C√¢mera n√£o est√° inicializada');
        }
        
        Logger.info('Capturando foto...');
        
        // Obter dimens√µes do v√≠deo
        const videoWidth = cameraVideo.videoWidth;
        const videoHeight = cameraVideo.videoHeight;
        
        if (videoWidth === 0 || videoHeight === 0) {
            throw new Error('V√≠deo da c√¢mera n√£o est√° pronto');
        }
        
        // Configurar canvas com as dimens√µes do v√≠deo
        cameraCanvas.width = videoWidth;
        cameraCanvas.height = videoHeight;
        
        // Desenhar frame atual do v√≠deo no canvas
        const ctx = cameraCanvas.getContext('2d');
        ctx.drawImage(cameraVideo, 0, 0, videoWidth, videoHeight);
        
        // Converter canvas para blob
        const photoBlob = await new Promise(resolve => {
            cameraCanvas.toBlob(resolve, CONFIG.CAMERA.PHOTO_FORMAT, CONFIG.CAMERA.PHOTO_QUALITY);
        });
        
        if (!photoBlob) {
            throw new Error('Falha ao capturar foto');
        }
        
        // Criar arquivo da foto
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const fileName = `foto_${currentTipo}_${timestamp}.jpg`;
        
        const photoFile = new File([photoBlob], fileName, {
            type: CONFIG.CAMERA.PHOTO_FORMAT,
            lastModified: Date.now()
        });
        
        Logger.success('Foto capturada', { 
            fileName: photoFile.name, 
            size: photoFile.size 
        });
        
        // Fechar c√¢mera
        closeCameraModal();
        
        // Iniciar upload automaticamente
        await uploadCapturedPhoto(photoFile);
        
    } catch (error) {
        Logger.error('Erro ao capturar foto', error);
        alert('Erro ao capturar foto: ' + error.message);
    }
}

/**
 * üì§ UPLOAD DE FOTO CAPTURADA
 * Faz upload da foto capturada pela c√¢mera
 */
async function uploadCapturedPhoto(photoFile) {
    try {
        if (!currentExibidora || !currentPontoId || !currentTipo) {
            throw new Error('Informa√ß√µes de contexto n√£o dispon√≠veis');
        }
        
        // Mostrar progresso
        showUploadProgress('Enviando foto capturada...');
        
        // Fazer upload
        const result = await DriveAPI.uploadFileToDrive(
            photoFile,
            currentExibidora,
            currentPontoId,
            currentTipo
        );
        
        hideUploadProgress();
        
        if (result.success) {
            Logger.success('Foto enviada com sucesso');
            
            // Mostrar mensagem de sucesso
            showSuccessMessage('üì∏ Foto enviada com sucesso!');
            
            // Recarregar lista de arquivos
            await refreshFilesList(currentExibidora, currentPontoId, currentTipo);
        } else {
            throw new Error(result.error || 'Falha no upload');
        }
        
    } catch (error) {
        hideUploadProgress();
        Logger.error('Erro no upload da foto capturada', error);
        alert('Erro ao enviar foto: ' + error.message);
    }
}

/**
 * üîí FECHAR MODAL DA C√ÇMERA
 * Para a c√¢mera e fecha o modal
 */
function closeCameraModal() {
    try {
        Logger.info('Fechando c√¢mera...');
        
        // Parar stream da c√¢mera
        if (cameraStream) {
            const tracks = cameraStream.getTracks();
            tracks.forEach(track => {
                track.stop();
                Logger.debug('Track da c√¢mera parado', { kind: track.kind });
            });
            cameraStream = null;
        }
        
        // Limpar v√≠deo
        if (cameraVideo) {
            cameraVideo.srcObject = null;
        }
        
        // Fechar modal
        document.getElementById('camera-modal').style.display = 'none';
        
        // Limpar vari√°veis
        cameraVideo = null;
        cameraCanvas = null;
        
        Logger.success('C√¢mera fechada');
        
    } catch (error) {
        Logger.error('Erro ao fechar c√¢mera', error);
    }
}

/**
 * üéØ DEFINIR CONTEXTO DA C√ÇMERA
 * Define qual exibidora/ponto/tipo est√° sendo usado
 */
function setCameraContext(exibidora, pontoId, tipo) {
    currentExibidora = exibidora;
    currentPontoId = pontoId;
    currentTipo = tipo;
    
    Logger.debug('Contexto da c√¢mera definido', { exibidora, pontoId, tipo });
}

/**
 * üì± VERIFICAR SUPORTE √Ä C√ÇMERA
 * Verifica se o dispositivo/navegador suporta c√¢mera
 */
function checkCameraSupport() {
    const hasUserMedia = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
    const hasGetUserMedia = !!(navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia);
    
    const support = {
        supported: hasUserMedia || hasGetUserMedia,
        modern: hasUserMedia,
        legacy: hasGetUserMedia && !hasUserMedia
    };
    
    Logger.debug('Suporte √† c√¢mera verificado', support);
    return support;
}

/**
 * üîÑ ALTERNAR C√ÇMERA
 * Alterna entre c√¢mera frontal e traseira (se dispon√≠vel)
 */
async function switchCamera() {
    try {
        if (!cameraStream) {
            throw new Error('C√¢mera n√£o est√° ativa');
        }
        
        Logger.info('Alternando c√¢mera...');
        
        // Parar stream atual
        const tracks = cameraStream.getTracks();
        tracks.forEach(track => track.stop());
        
        // Determinar nova configura√ß√£o
        const currentFacingMode = CONFIG.CAMERA.VIDEO_CONSTRAINTS.facingMode;
        const newFacingMode = currentFacingMode === 'environment' ? 'user' : 'environment';
        
        // Tentar nova c√¢mera
        const newConstraints = {
            ...CONFIG.CAMERA.VIDEO_CONSTRAINTS,
            facingMode: newFacingMode
        };
        
        cameraStream = await navigator.mediaDevices.getUserMedia({
            video: newConstraints,
            audio: false
        });
        
        // Atualizar v√≠deo
        cameraVideo.srcObject = cameraStream;
        
        // Atualizar configura√ß√£o
        CONFIG.CAMERA.VIDEO_CONSTRAINTS.facingMode = newFacingMode;
        
        Logger.success('C√¢mera alternada', { facingMode: newFacingMode });
        
    } catch (error) {
        Logger.warning('N√£o foi poss√≠vel alternar c√¢mera', error);
        // Tentar voltar para a c√¢mera original
        try {
            cameraStream = await navigator.mediaDevices.getUserMedia({
                video: CONFIG.CAMERA.VIDEO_CONSTRAINTS,
                audio: false
            });
            cameraVideo.srcObject = cameraStream;
        } catch (fallbackError) {
            Logger.error('Erro ao restaurar c√¢mera original', fallbackError);
            closeCameraModal();
        }
    }
}

/**
 * üìè OBTER RESOLU√á√ÉO DISPON√çVEL
 * Lista as resolu√ß√µes de v√≠deo dispon√≠veis
 */
async function getAvailableResolutions() {
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        const track = stream.getVideoTracks()[0];
        const capabilities = track.getCapabilities();
        
        // Parar stream de teste
        track.stop();
        
        const resolutions = {
            width: capabilities.width,
            height: capabilities.height,
            frameRate: capabilities.frameRate
        };
        
        Logger.debug('Resolu√ß√µes dispon√≠veis', resolutions);
        return resolutions;
        
    } catch (error) {
        Logger.warning('N√£o foi poss√≠vel obter resolu√ß√µes dispon√≠veis', error);
        return null;
    }
}

// üöÄ EXPORTAR FUN√á√ïES
window.CameraManager = {
    openCamera,
    capturePhoto,
    closeCameraModal,
    setCameraContext,
    checkCameraSupport,
    switchCamera,
    getAvailableResolutions
};

// üéØ EXPOR FUN√á√ïES GLOBAIS PARA USO NO HTML
window.openCamera = openCamera;
window.capturePhoto = capturePhoto;
window.closeCameraModal = closeCameraModal;

Logger.info('M√≥dulo de c√¢mera carregado');

// üß™ VERIFICAR SUPORTE INICIAL
document.addEventListener('DOMContentLoaded', () => {
    const support = checkCameraSupport();
    if (!support.supported) {
        Logger.warning('C√¢mera n√£o √© suportada neste dispositivo/navegador');
        
        // Ocultar bot√µes de c√¢mera se n√£o houver suporte
        const cameraButtons = document.querySelectorAll('.btn-camera');
        cameraButtons.forEach(btn => {
            if (btn.textContent.includes('üì∑')) {
                btn.style.display = 'none';
            }
        });
    }
});
